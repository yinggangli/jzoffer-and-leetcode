## JZ5  替换空格 :flushed:
`简单` `题目`<br>
*请实现一个函数，把字符串 s 中的每个空格替换成"%20"。* <br><br>
`考点`<br>
<br>
`代码`<br>
```java
class Solution {
    public String replaceSpace(String s) {
        int n = s.length();
        char[] array = new char[n * 3];
        int index = 0;
        for(int i=0; i<n; i++){
            char c = s.charAt(i);
            if(c == ' '){
                array[index ++] = '%';
                array[index ++] = '2';
                array[index ++] = '0';
            } else{
                array[index ++] = c;
            }
        }
        String res = new String(array, 0, index);
        return res;
    }
}
```
## JZ38  字符串的排列 :flushed:
`中等` `题目`<br>
*输入一个字符串，打印出该字符串中字符的所有排列。你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。* <br><br>
`考点`<br>
递归<br>
回溯<br><br>
`代码`<br>
```java
class Solution {
    Set<String> res = new HashSet<>();//保存结果
    public String[] permutation(String s) {
        if(s == null) return new String[]{};
        boolean[] visited = new boolean[s.length()];

        dfs(s, "", visited);

        return res.toArray(new String[res.size()]);
    }
    private void dfs(String s, String ch, boolean[] visited){
        if(s.length() == ch.length()){//说明已经得到一个完整的排列
            res.add(ch);
            return;
        }
        for(int i=0; i<s.length(); i++){
            char temp = s.charAt(i);
            if(visited[i]) continue;
            visited[i] = true;//回溯
            dfs(s, ch + String.valueOf(temp), visited);//递归
            visited[i] = false;
        }
    }
}
```
## JZ50  第一个只出现一次的字符 :flushed:
`简单` `题目`<br>
*在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。* <br><br>
`考点`<br>
递归<br><br>
`代码`<br>
```java
class Solution {
    public char firstUniqChar(String s) {
        Map<Character, Boolean> map = new HashMap<>();
        char[] ch = s.toCharArray();
        for(char c : ch) map.put(c, !map.containsKey(c));//先插入true，如果重复就变成false
        for(char c : ch) 
            if(map.get(c)) return c;
        return ' ';       
    }
}
```
```java
class Solution {
    public char firstUniqChar(String s) {
        if(s == null) return ' ';
        Map<String, Integer> map = new HashMap<>();
        for(int i=0; i<s.length(); i++){
            map.put(s.charAt(i) + "", 0);
        }
        int count = 0;
        for(int i=0; i<s.length(); i++){
            count = map.get(s.charAt(i) + "");
            count ++;
            map.put(s.charAt(i) + "", count);
        }
        for(int i=0; i<s.length(); i++){
            count = map.get(s.charAt(i) + "");
            if(count == 1) return s.charAt(i);
        }
        return ' ';
        
    }
}
```
## JZ58  翻转单词顺序 :flushed:
`简单` `题目`<br>
*输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student. "，则输出"student. a am I"。* <br><br>
`考点`<br><br>
`代码`<br>
```java
class Solution {
    public String reverseWords(String s) {
        s = s.trim();
        int j = s.length() - 1;
        int i = j;
        StringBuilder res = new StringBuilder();
        while(i >= 0){
            while(i >= 0 && s.charAt(i) != ' ') i--;
            res.append(s.substring(i + 1, j + 1) + " ");//String类的substring方法，开始处的索引包括，结尾处的索引不包括
            while(i >= 0 && s.charAt(i) == ' ') i--;
            j = i;
        }
        return res.toString().trim();
    }
}
```
## JZ67  把字符串转换成整数 :flushed:
`中等` `题目`<br>
*写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。

 

首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。

当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。

该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。

注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。

在任何情况下，若函数不能进行有效的转换时，请返回 0。

说明：

假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。

* <br><br>
`考点`<br><br>
`代码`<br>
```java
class Solution {
    public int strToInt(String str) {
        //2^31 - 1
        //-2^32
        // 2147483647  214748364 + 还有一个数字 与7比较大小
        //-2147483648  214748364 + 还有一个数字
        char[] c = str.trim().toCharArray();
        if(c.length == 0) return 0;
        int res = 0;
        int sign = 1;//返回结果正负 sign=0 为负  sign=1 为正
        int temp = Integer.MAX_VALUE / 10;// = 214748364
        
        int index = 1;
        if(c[0] == '-') sign = -1;
        else if(c[0] != '+') index = 0;//如果第0位不是正号，则从第0位开始，如果第0位是正号，则从第1位开始

        for(int i=index; i<c.length; i++){
            if(c[i] < '0' || c[i] > '9') break;
            if(res > temp || (res == temp && c[i] > '7'))
                return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
            res = res * 10 + c[i] - '0';
        }
        return sign * (int)res;
    }
}
```
## JZ19 正则表达式匹配 :flushed:
`困难` `题目`<br>
*请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配。* <br><br>
`考点`<br><br>
`代码`<br>
```java
class Solution {
    public boolean isMatch(String s, String p) {
        //动态规划的思路
        //f[i][j]表示s的前i个字符和p的前j个字符相匹配
        int n = s.length();
        int m = p.length();
        boolean[][] f = new boolean[n+1][m+1];

        for(int i=0; i<=n; i++){
            for(int j=0; j<=m; j++){
                if(j == 0) // i == j == 0
                    f[i][j] = (i == 0);
                else{
                    //判断是否有*
                    if(p.charAt(j - 1) != '*'){
                        //没有碰到*
                        if(i > 0 && ((s.charAt(i - 1) == p.charAt(j - 1)) || p.charAt(j - 1) == '.')) 
                            f[i][j] = f[i - 1][j - 1];
                    } else{
                        //碰到*了
                        //* = 0
                        if(j >= 2)
                            f[i][j] |= f[i][j - 2];
                        if(i >= 1 && j >= 2 && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.'))
                            f[i][j] |= f[i - 1][j];
                    }
                }
            }
        }
        return f[n][m];
    }
}
```
