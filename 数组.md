## JZ6  旋转数组的最小数 :flushed:
`简单` `题目`<br>
*把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。* <br><br>
`考点`<br>
二分查找，对有序数组排序<br>
非递减排序数组左右的元素大小关系为:array[left] <= array[right] 要找到旋转数组的最小元素，即需要找到数组顺序的分界元素<br><br>
`代码`<br>
```java
class Solution{
  public int minArray(int[] nums){
    //3 4 5 1 2 3 3 3 3
    //首先去掉最末尾重复的部分
    //3 4 5 1 2 
    int n = nums.length - 1;
    if(n < 0) return 0;
    while(n > 0 && nums[n] == nums[0]) n --;
    
    //如果数组没有旋转，则直接返回第一个数
    if(nums[0] <= nums[n]) return nums[0];
    
    //二分
    int l = 0;
    int r = n;
    while(l < r){
      int mid = (l + r) / 2;
      if(nums[mid] < nums[0]) r = mid;
      else l = mid + 1;
    }
    return nums[l];//或nums[r]
  }
}
```
## JZ4 二维数组中的查找 :flushed:
`简单` `题目`<br>
*在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。*<br><br>
`考点`<br>
数组<br><br>
`代码`<br>
```java
class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        if(matrix == null || matrix.length == 0 || (matrix.length == 1 && matrix[0].length == 0)) return false;
        int i = 0;
        int j = matrix[0].length - 1;
        while((i <= matrix.length -1) && (j >= 0)){
            if(matrix[i][j] == target) {
                return true;
            } else if(matrix[i][j] < target) {
                i ++;
            } else if(matrix[i][j] > target) {
                j --;
            }
        }
        return false;
    }
}
```
## JZ21 调整数组顺序使奇数位于偶数前面 :flushed:
`简单` `题目`<br>
*输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。*<br><br>
`考点`<br>
数组<br><br>
`代码`<br>
```java
class Solution {
    public int[] exchange(int[] nums) {
        int left = 0;
        int right = nums.length - 1;
        while(left < right){
            //找到左边第一个偶数
            while(left < right && nums[left] % 2 == 1) left ++;
            //找到右边第一个奇数
            while(left < right && nums[right] % 2 == 0) right --;
            
            if(left < right){
                int temp = nums[left];
                nums[left] = nums[right];
                nums[right] = temp;
            }
        }
        return nums;
    }
}
```
```java
class Solution {
    public int[] exchange(int[] nums) {
        //执行时间复杂度和空间复杂度都更高
        ArrayList<Integer> list = new ArrayList<>();
        int temp;
        for(int i=0; i<nums.length; i++){
            if(nums[i] % 2 == 0) list.add(i);
            if(!(nums[i] % 2 == 0) && (list.size() != 0)){
                temp = nums[i];
                nums[i] = nums[list.get(0)];
                nums[list.get(0)] = temp;
                list.remove(0);
                list.add(i);
            }
        }
        return nums;
    }
}
```
## JZ39 数组中出现次数超过一半的数字 :flushed:
`简单` `题目`<br>
*数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。你可以假设数组是非空的，并且给定的数组总是存在多数元素。*<br><br>
`考点`<br>
数组<br><br>
`代码`<br>
```java
class Solution {
    public int majorityElement(int[] nums) {
        int val  = -1;
        int count = 0;
        for(int num : nums){
            if(num == val) count ++;
            else{
                if(count >= 1) count--;
                else{
                    val = num;
                    count = 1;
                }
            }
        }
        return val;
    }
}
```
```java
//使用hash表
//执行效率更低
class Solution {
    public int majorityElement(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();
        for(int i=0; i<nums.length; i++){
            map.put(nums[i], 0);
            }
        int count = 0;
        for(int i=0; i<nums.length; i++){
            count = map.get(nums[i]);
            count += 1;
            map.put(nums[i], count);
            if(count > nums.length / 2) return nums[i];
            count = 0;
        }
        return 0;
    }
}
```
## JZ42 连续子数组的最大和 :flushed:
`简单` `题目`<br>
*输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。。*<br><br>
`考点`<br>
动态规划<br><br>
`代码`<br>
```java
class Solution {
    public int maxSubArray(int[] nums) {
        int cur = nums[0];
        int res = nums[0];
        for(int i=1; i<=nums.length - 1; i++){
            if(cur < 0) cur = nums[i];
            else cur = cur + nums[i];
            if(res < cur) res = cur;
        }
        return res;

    }
}
```
```java
class Solution {
    public int maxSubArray(int[] nums) {
        int res = nums[0];
        for(int i=1; i<=nums.length -1; i++){
            nums[i] += Math.max(nums[i - 1], 0);
            res = Math.max(res, nums[i]);
        }
        return res;
    }
}
```
## JZ45 把数组排成最小的数 :flushed:
`中等` `题目`<br>
*输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。*<br><br>
`考点`<br>
字符串排序<br>
快速排序<br><br>
`代码`<br>
```java
class Solution {
    public String minNumber(int[] nums) {
        String[] str = new String[nums.length];
        for(int i=0; i<nums.length; i++){
            str[i] = String.valueOf(nums[i]);
        }
        //字符串排序
        strSort(str, 0, str.length - 1);

        //字符串数组依次组合
        // StringBuilder res = new StringBuilder();
        // for(String s : str){
        //     res.append(s);
        // }
        // return res.toString();

        String res = "";
        for(int j=0; j<str.length; j++){
           res += str[j];
        }
        return res;
    }
    public void strSort(String[] str, int left, int right){
        //快排写法
        if(left > right) return;
        int i = left;
        int j = right;
        String temp = str[i];
        while(i != j){
            while((str[j] + str[left]).compareTo(str[left] + str[j]) >= 0 && i < j) j --;
            while((str[i] + str[left]).compareTo(str[left] + str[i]) <= 0 && i < j) i ++;
            temp = str[i];
            str[i] = str[j];
            str[j] = temp;
        }

        str[i] = str[left];
        str[left] = temp;
        strSort(str, left, i -1);
        strSort(str, i + 1, right);
    }
}
```
## JZ45 数组中的逆序对 :flushed:???
`困难` `题目`<br>
*在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。*<br><br>
`考点`<br>
归并排序<br><br>
`代码`<br>
```java
class Solution {
    public int reversePairs(int[] nums) {
        int len = nums.length;
        if(len < 2) return 0;
        int[] temp = new int[len];
        return mergeSort(nums, 0, len - 1, temp);
    }
    private int mergeSort(int[] nums, int left, int right, int[] temp){
        //递归终止条件
        if(left >= right) return 0;
        int mid = left + (right - left) / 2;//防止溢出
        //左区间逆序对的数量[left, mid]
        int leftPairs = mergeSort(nums, left, mid, temp);
        //右区间逆序对的数量[mid + 1, right]
        int rightPairs = mergeSort(nums, mid + 1, right, temp);
        
        if(nums[mid] <= nums[mid + 1]){
            return leftPairs + rightPairs;
        }
        //跨区间的逆序对
        int crossPairs = mergeSortCross(nums, left, mid, right, temp);

        return leftPairs + rightPairs + crossPairs;
    }
    private int mergeSortCross(int[] nums, int left, int mid, int right, int[] temp){
        for(int i=left; i<=right; i++) temp[i] = nums[i];
        int i = left;
        int j = mid + 1;
        //[left  i  mid]  [mid+1  j  right]
        int count = 0;
        for(int k=left; k<=right; k++){
            if(i == mid + 1){
                nums[k] = temp[j];
                j++;
            } else if(j == right + 1){
                nums[k] = temp[i];
                i ++;
            } else if(temp[i] <= temp[j]){
                //没有逆序对
                nums[k] = temp[i];
                i ++;
            }else{
                //有逆序对
                nums[k] = temp[j];
                j ++;
                count += mid - i + 1;
            }
        }
        return count;
    }
}
```
## JZ53 在排序数组中查找数字 I :flushed:???
`困难` `题目`<br>
*统计一个数字在排序数组中出现的次数。*<br><br>
`考点`<br>
二分查找<br><br>
`代码`<br>
```java
class Solution {
    public int search(int[] nums, int target) {
        if(nums == null || nums.length == 0) return 0;
        int start = binarySearch(nums, target);
        int end = binarySearch(nums, target + 1);
        return end - start + (nums[end] == target ? 1 : 0);
    }
    private int binarySearch(int[] nums, int target){
        int l = 0;
        int r = nums.length - 1;
        while(l < r){
            int mid = l + (r - l)/2;
            if(nums[mid] < target) l = mid + 1;
            else r = mid;
        }
        return l;
    }
}
```
## JZ56 数组中数字出现的次数 :flushed:？？？为什么要找到异或结果中第一个1所在的位置，而不是最后一个
`困难` `题目`<br>
*一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。*<br><br>
`考点`<br>
位运算<br>
异或运算<br>
异或的一条性质：任何一个数与自己做异或运算，结果都为0<br>
也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那两个只出现一次的数字的异或结果，因为出现过两次的数字异或后都被抵消了<br>
接下来的是通过前一步的异或结果，找到那两个只出现过一次的数字。从头到尾一次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数组的异或结果。因为其他数字都出现了两次，在异或中全部抵消了。由于两个数字肯定不一样，那么异或的结果肯定不为0，也就是说这个结果数组的二进制表示至少有一个位为1。我们在异或得到的二进制结果中找到第一个为1的位的位置，将这个位置记为第n位。现在我们以第n位是不是1为标准把元数组中的数字分成两个子数组，第一个子数组中每个数字的第n位都是1，而第二个子数组中每个数字的第n位都是0。得到的两个子数组中各自包含了一个出现了一次的元素，只需要分别将两个子数组中的元素从头到尾都异或起来，就可以得到对应子数组中只出现了一次的元素<br><br>
`代码`<br>
```java
class Solution {
    public int[] singleNumbers(int[] nums) {
        int sum = 0;//异或
        for(int x : nums) sum ^= x;
        //sum = first ^ second
        //找到二进制中第一个1所在的那个位置
        int index = 0;
        while((sum >> index & 1) == 0) index++;
        int first = 0;
        for(int x : nums)
            if((x >> index & 1) == 0) first ^= x;
        int second = sum ^ first;
        //d = a ^ b ^ c 可以推出 a = d ^ b ^ c
        return new int[]{first, second};
    }
}
```
## JZ3 数组中重复的数字 :flushed:
`简单` `题目`<br>
*在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。*<br><br>
`考点`<br>
数组<br><br>
`代码`<br>
```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        int n = nums.length;
        for(int num : nums)
            if(num < 0 || num >= n)
                return -1;
        //利用下标交换 将元素值放到下标值等于元素值的对应位置 如果数组元素重复 则交换不成功 即为重复值
        for(int i=0; i<n; i++){
            while(nums[i] != i && nums[nums[i]] != nums[i]) swap(nums, i, nums[i]);
            if(nums[i] != i && nums[nums[i]] == nums[i]) return nums[i];
        }
        return -1;
        
    }
    public void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp; 
    }
}
```
```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        //使用Hash表实现
        Set<Integer> set = new HashSet<>();
        int res = -1;
        for(int num : nums){
            if(!set.add(num)) {
                res = num;
                break;
            }
        }
        return res;
    }
}
```
