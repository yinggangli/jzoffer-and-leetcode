## JZ5  用两个栈实现队列 :flushed:
`简单` `题目`<br>
*用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。*<br>
<br>
`考点`<br>
栈 队列<br>
栈 先进后出<br>
队列 先进后出<br>
<br>
`代码`<br>
```java
import java.util.Stack;

public class Solution {
    //栈    先进后出
    //队列  先进先出
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    int size = 0;
    
    public void push(int node) {
        //插入一个元素
        //stack1保存 队列的底部存新插入的，顶部存老的元素
        //可以看作两个竹筒倒豌豆
        while(!stack1.isEmpty()) stack2.push(stack1.pop());
        stack1.push(node);
        while(!stack2.isEmpty()) stack1.push(stack2.pop());
        size ++;
    }
    
    public int pop() {
        //删除队列的首部元素
        if(size == 0) return 0;
        int res = stack1.pop();
        size --;
        return res;
    }
}
```
## JZ5  栈的压入，弹出序列 :flushed:
`简单` `题目`<br>
*输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的。*<br>
<br>
`考点`<br>
栈<br>
`分析`<br>
栈可以一边压入一边弹出，其压入和弹出的顺序可以是：<br>
1,2,3,4---弹出4<br>
5---------弹出5----弹出3----弹出2----弹出1<br>
压入顺序为1,2,3,4,5<br>
弹出顺序为4,5,3,2,1<br>
1不可能在2之前弹出，所以4,3,5,1,2不会是弹出序列

`代码`<br>
```java
import java.util.ArrayList;
import java.util.*;
public class Solution {
    public boolean IsPopOrder(int [] pushA,int [] popA) {
        if(popA == null | pushA.length != popA.length) return false;
        Stack<Integer> temp = new Stack<>();
        int i = 0;
        for(int num:pushA){
            temp.add(num);//压栈
            //模拟出栈
            while(!temp.isEmpty() && temp.peek() == popA[i]){
                temp.pop();
                i ++;
            }
        }
        return temp.isEmpty();
    }
}
```
`java Stack中的add与push, peek与pop`<br>
add&push<br>
```java
相同点：add，push都可以向Stack中添加元素
不同点：add是继承自Vector的方法，返回值是boolean；push是Stack自身的方法，返回值类型是参数类型
```
peek&pop<br>
```java
相同点：都是返回栈顶元素<br>
不同点：peek返回栈顶元素但不弹出栈顶元素；pop返回并弹出栈顶元素<br>
```
