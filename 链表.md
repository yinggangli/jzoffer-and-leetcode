

## JZ16  合并两个排序的链表 :flushed:
`入门` `题目`<br>
*输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。*<br><br>
`考点`<br>
 链表<br>
 归并<br>
 递归<br><br>
 
`代码`<br>
```java
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        //归并排序的思想
        if(list1==null) return list2;
        if(list2==null) return list1;
        
        ListNode head = null;
        ListNode cur = null;
        
        while(list1 !=null && list2 != null){
            if(list1.val < list2.val){
                if(head==null){
                    head = list1;
                    cur = head;
                } else{
                    cur.next = list1;
                    cur = cur.next;
                }
                list1 = list1.next;
            } else{
                if(head==null){
                    head = list2;
                    cur = head;
                } else{
                    cur.next = list2;
                    cur = cur.next;
                }
                list2 = list2.next;
            }
        }
        
        if(list1 == null) cur.next = list2;
        if(list2 == null) cur.next = list1;
        return head;
    }
}
```
```java
//归并
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        if(list1 == null){
            return list2;
        }
        if(list2 == null){
            return list1;
        }
        while(list1 != null && list2 != null){
            if(list1.val < list2.val){  //比较list1的val 与 list2的val
                //将list2的元素添加到list1中，直到list1.val 》 list2.val
                list1.next = Merge(list1.next,list2); 
                return list1;												
            }else{
                //将list1的元素添加到list2中，直到list1.val 《 list2.val
                list2.next = Merge(list1,list2.next);
                return list2;
            }
        }
        return list1; //list1 == list2
    }
}
```
`链表的实现代码`
```java
public class Node{
    Object data;
    Node next;
    public Node(){}
    public Node(Object data, Node next){
        this.data = data;
        this.next = next
    }
}

public class Link{
    Node header;
    int index = 0;
    public void add(Object data){
        if(null == header){
            header = new Node(data, null);
        } else{
            Node currentFinalNode = findLastNode(header);
            currentFinalNode.next = new Node(data, null)
        }
        this.index ++;
    }
    public Node findLastNode(Node node){
        if(node.next == null) return node;
        return findLastNode(node);
    }
}
```
```java
public class Node {
    public int val;
    public Node next = null;
    public Node() {}
    public Node(int val) { this.val = val;}
}

public class Link {
    private Node head = null;

    public boolean add(int a){
        Node newNode = new Node(a);
        if (head == null){
            head = newNode;
            return true;
        }
        //如果头节点不为空，则需要找到尾部节点
        Node curNode = head;
        while (curNode.next != null){
            curNode = curNode.next;
        }
        curNode.next = newNode;
        return true;
    }

    public boolean delete(int a){
        if (head == null) return false;
        if (head.val == a){
            head = head.next;
            return true;
        }
        Node curNode = head;
        while (curNode.next != null){
            if (curNode.next.val == a){
                curNode.next = curNode.next.next;
                return true;
            }
            curNode = curNode.next;
        }
        return false;
    }

    public int size(){
        int length = 0;
        Node curNode = head;
        while (curNode != null){
            length ++;
            curNode = curNode.next;
        }
        return length;
    }

    public int find(int a){//查找节点，返回下标
        Node curNode = head;
        int flag = 0;
        while (curNode.next != null){
            if (curNode.val != a){
                flag ++;
                curNode = curNode.next;
            }
            return flag;
        }
        return -1;
    }

    public Node get(int a){//用下标查找节点
        if (head == null) return null;
        Node curNode = head;
        for (int i=0; i<a; i++){
            curNode = curNode.next;
        }
        return curNode;
    }
}
```
## JZ15  反转链表 :flushed:
`简单` `题目`<br>
*输入一个链表，反转链表后，输出新链表的表头。* <br><br>
`考点`<br>
链表<br><br>
`代码`<br>
```java
public class Solution {
    public ListNode ReverseList(ListNode head) {
        ListNode cur = head;
        ListNode pre = null;
        if(head==null) return null;
        while(cur != null){
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
}
```
## JZ3  从尾到头打印链表 :flushed:
`较难` `题目`<br>
*输入一个链表，按链表从尾到头的顺序返回一个ArrayList。例如输入{1, 2, 3, 4, 5, 6}，输出{6, 5, 4, 3, 2, 1}* <br><br>
`考点`<br>
链表<br><br>
`代码`<br>
```java
//解法一：(执行效率最高的一种)
import java.util.ArrayList;
import java.util.Stack;
public class Solution {
    ArrayList<Integer> arrayList = new ArrayList<>();
    //不使用栈
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
       int size = 0;
       ListNode temp = listNode;
       while(temp != null){
           size ++;
           temp = temp.next;
       }
       
       int[] list = new int[size];
       for(int i = size -1; i >= 0; i--){
           list[i] = listNode.val;
           listNode = listNode.next;
           
       }
       for(int i=0; i<size; i++){
           arrayList.add(list[i]);
       }
       return arrayList;
        
    }
}
```
```java
//解法二：压栈
import java.util.ArrayList;
import java.util.Stack;
public class Solution {
    ArrayList<Integer> list = new ArrayList<>();
    Stack<Integer> stack = new Stack<>();
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        while(listNode != null){
            stack.push(listNode.val);
            listNode = listNode.next;
        }
        while(!stack.isEmpty()) list.add(stack.pop());
        return list;
    }
}

```
```java
//解法三：链表反转
import java.util.ArrayList;
public class Solution {
    ArrayList<Integer> list = new ArrayList<>();
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ListNode reNode = reverseNode(listNode);
        while(reNode != null){
            list.add(reNode.val);
            reNode = reNode.next;
        }
        return list;
    }
    public ListNode reverseNode(ListNode listNode){
        ListNode cur = listNode;
        ListNode pre = null;
        if(listNode == null) return listNode;
        while(cur != null){
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
}
```
`ArrayList和Array的区别`<br>
详见后台学习笔记中的java面试考点中的java语言基础
