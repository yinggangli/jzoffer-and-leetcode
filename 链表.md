

## JZ16  合并两个排序的链表 :flushed:
`入门` `题目`<br>
*输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。*<br><br>
`考点`<br>
 链表<br>
 归并<br>
 递归<br><br>
 
`代码`<br>
```java
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        //归并排序的思想
        if(list1==null) return list2;
        if(list2==null) return list1;
        
        ListNode head = null;
        ListNode cur = null;
        
        while(list1 !=null && list2 != null){
            if(list1.val < list2.val){
                if(head==null){
                    head = list1;
                    cur = head;
                } else{
                    cur.next = list1;
                    cur = cur.next;
                }
                list1 = list1.next;
            } else{
                if(head==null){
                    head = list2;
                    cur = head;
                } else{
                    cur.next = list2;
                    cur = cur.next;
                }
                list2 = list2.next;
            }
        }
        
        if(list1 == null) cur.next = list2;
        if(list2 == null) cur.next = list1;
        return head;
    }
}
```
```java
//归并
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        if(list1 == null){
            return list2;
        }
        if(list2 == null){
            return list1;
        }
        while(list1 != null && list2 != null){
            if(list1.val < list2.val){  //比较list1的val 与 list2的val
                //将list2的元素添加到list1中，直到list1.val 》 list2.val
                list1.next = Merge(list1.next,list2); 
                return list1;												
            }else{
                //将list1的元素添加到list2中，直到list1.val 《 list2.val
                list2.next = Merge(list1,list2.next);
                return list2;
            }
        }
        return list1; //list1 == list2
    }
}
```
`链表的实现代码`
```java
public class Node{
    Object data;
    Node next;
    public Node(){}
    public Node(Object data, Node next){
        this.data = data;
        this.next = next
    }
}

public class Link{
    Node header;
    int index = 0;
    public void add(Object data){
        if(null == header){
            header = new Node(data, null);
        } else{
            Node currentFinalNode = findLastNode(header);
            currentFinalNode.next = new Node(data, null)
        }
        this.index ++;
    }
    public Node findLastNode(Node node){
        if(node.next == null) return node;
        return findLastNode(node);
    }
}
```
```java
public class Node {
    public int val;
    public Node next = null;
    public Node() {}
    public Node(int val) { this.val = val;}
}

public class Link {
    private Node head = null;

    public boolean add(int a){
        Node newNode = new Node(a);
        if (head == null){
            head = newNode;
            return true;
        }
        //如果头节点不为空，则需要找到尾部节点
        Node curNode = head;
        while (curNode.next != null){
            curNode = curNode.next;
        }
        curNode.next = newNode;
        return true;
    }

    public boolean delete(int a){
        if (head == null) return false;
        if (head.val == a){
            head = head.next;
            return true;
        }
        Node curNode = head;
        while (curNode.next != null){
            if (curNode.next.val == a){
                curNode.next = curNode.next.next;
                return true;
            }
            curNode = curNode.next;
        }
        return false;
    }

    public int size(){
        int length = 0;
        Node curNode = head;
        while (curNode != null){
            length ++;
            curNode = curNode.next;
        }
        return length;
    }

    public int find(int a){//查找节点，返回下标
        Node curNode = head;
        int flag = 0;
        while (curNode.next != null){
            if (curNode.val != a){
                flag ++;
                curNode = curNode.next;
            }
            return flag;
        }
        return -1;
    }

    public Node get(int a){//用下标查找节点
        if (head == null) return null;
        Node curNode = head;
        for (int i=0; i<a; i++){
            curNode = curNode.next;
        }
        return curNode;
    }
}
```
## JZ15  反转链表 :flushed:
`简单` `题目`<br>
*输入一个链表，反转链表后，输出新链表的表头。* <br><br>
`考点`<br>
链表<br><br>
`代码`<br>
```java
public class Solution {
    public ListNode ReverseList(ListNode head) {
        ListNode cur = head;
        ListNode pre = null;
        if(head==null) return null;
        while(cur != null){
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
}
```
## JZ3  从尾到头打印链表 :flushed:
`较难` `题目`<br>
*输入一个链表，按链表从尾到头的顺序返回一个ArrayList。例如输入{1, 2, 3, 4, 5, 6}，输出{6, 5, 4, 3, 2, 1}* <br><br>
`考点`<br>
链表<br><br>
`代码`<br>
```java
//解法一：(执行效率最高的一种)
import java.util.ArrayList;
import java.util.Stack;
public class Solution {
    ArrayList<Integer> arrayList = new ArrayList<>();
    //不使用栈
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
       int size = 0;
       ListNode temp = listNode;
       while(temp != null){
           size ++;
           temp = temp.next;
       }
       
       int[] list = new int[size];
       for(int i = size -1; i >= 0; i--){
           list[i] = listNode.val;
           listNode = listNode.next;
           
       }
       for(int i=0; i<size; i++){
           arrayList.add(list[i]);
       }
       return arrayList;
        
    }
}
```
```java
//解法二：压栈
import java.util.ArrayList;
import java.util.Stack;
public class Solution {
    ArrayList<Integer> list = new ArrayList<>();
    Stack<Integer> stack = new Stack<>();
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        while(listNode != null){
            stack.push(listNode.val);
            listNode = listNode.next;
        }
        while(!stack.isEmpty()) list.add(stack.pop());
        return list;
    }
}

```
```java
//解法三：链表反转
import java.util.ArrayList;
public class Solution {
    ArrayList<Integer> list = new ArrayList<>();
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ListNode reNode = reverseNode(listNode);
        while(reNode != null){
            list.add(reNode.val);
            reNode = reNode.next;
        }
        return list;
    }
    public ListNode reverseNode(ListNode listNode){
        ListNode cur = listNode;
        ListNode pre = null;
        if(listNode == null) return listNode;
        while(cur != null){
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
}
```
`ArrayList和Array的区别`<br>
详见后台学习笔记中的java面试考点中的java语言基础
## JZ25  复杂链表的复制 :flushed:
`较难` `题目`<br>
*输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）* <br><br>
`考点`<br>
链表<br><br>
`代码`<br>
```java
/*
思路：
1.复制节点 节点7 8 9 10
             7 7’ 8 8’ 9 9’ 10 10’
2.复制random指针
             7 random 9
             7’ random 9 9’
3.分离出来
             7’ 8’ 9’ 10’
*/
public class Solution {
    public RandomListNode Clone(RandomListNode pHead)
    {
        if(pHead == null) return null;
        copy(pHead);//复制节点
        copyRandom(pHead);//复制random指针
        return divide(pHead);//分离出来
    }
    private void copy(RandomListNode head){
        while(head != null){
            RandomListNode clone = new RandomListNode(head.label);
            clone.next = head.next;
            head.next = clone;
            head = clone.next;
        }
    }
    private void copyRandom(RandomListNode head){
        while(head != null){
            RandomListNode clone = head.next;
            if(head.random != null){
                clone.random = head.random.next;
            }
            head = clone.next;
        }
    }
    private RandomListNode divide(RandomListNode head){
        RandomListNode cloneHead = head.next;
        RandomListNode cloneNode = cloneHead;
        head.next = cloneNode.next;
        head = head.next;
        while(head != null){
            cloneNode.next = head.next;
            head.next = head.next.next;
            head = head.next;
            cloneNode = cloneNode.next;
        }
        return cloneHead;
    }
}
```
```java
//错误代码示例
//为什么不行？？？？？？
private RandomListNode divide(RandomListNode head){
        RandomListNode cloneHead = head.next;
        RandomListNode cloneNode = cloneHead;
        while(head != null){
            head.next = head.next.next;
            head = head.next;
            cloneNode.next = head.next;
            cloneNode = cloneNode.next;
        }
        return cloneHead;
```
## JZ36 两个链表的第一个公共节点 :flushed:
`中等` `题目`<br>
*输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）* <br><br>
`考点`<br>
链表<br><br>
`代码`<br>
```java
public class Solution {
    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
        if(pHead1 == pHead2) return pHead1;
        if(pHead1 == null | pHead2 == null) return null;
        ListNode indexA = pHead1;
        ListNode indexB = pHead2;
        while(indexA != indexB){
            if(indexA == null) indexA = pHead2;
            else indexA = indexA.next;
            if(indexB == null) indexB = pHead1;
            else indexB = indexB.next;
        }
        return indexA;
    }
```
## JZ36 链表中环的入口节点 :flushed:
`中等` `题目`<br>
*给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。* <br><br>
`考点`<br>
链表<br>
哈希表<br><br>
`思路`<br>
分析：通过双指针的方式，设快指针p1的前进速度是慢指针p2的两倍，两个指针从head节点同时出发。设head到入口节点的距离为a，入口节点到第一次相遇的节点距离为b，第一次相遇的节点到入口节点的距离为c<br>
由于快指针p1走过的距离是慢指针p2的两倍，所以有：<br>
2(a + b) = a + (b + c)*k + b<br>
a = (k -1)*s + c<br>
其中k为快指针p1在环上走的圈数，k >= 1，s为环的长度<br>
此时，让快指针回到head节点，让快指针p1与慢指针p2以相同的节点前进<br>
当p1从起点开始走过距离a，到达入口节点时，p2从第一次相遇的几点开始走过的距离为(k - 1)*s + c，刚好也到达入口节点
<br>
`代码`<br><br>
```java
import java.util.*;
public class Solution {

    public ListNode EntryNodeOfLoop(ListNode pHead)
    {
        //通过双指针来做
        if(pHead == null) return null;
        ListNode fast = pHead;
        ListNode slow = pHead;
        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
            if(fast == slow){
                fast = pHead;
                while(fast != slow){
                    fast = fast.next;
                    slow = slow.next;
                }
                if(fast == slow) return slow;
            }
        }
        return null;
    }
}
```
```java
import java.util.*;
public class Solution {

    public ListNode EntryNodeOfLoop(ListNode pHead)
    {
        //通过hash表的元素不可重复的性质来做
        Set<ListNode> hash = new HashSet<>();
        while(pHead != null){
           if(!hash.add(pHead)) return pHead;
           pHead = pHead.next;
        }
        return null;
    }
}
```
`关于java中Set集合数据结构`<br>
HashSet类实现了Set接口，Set集合中的元素都是无序不可重复的。具体详见java学习笔记中的图片
